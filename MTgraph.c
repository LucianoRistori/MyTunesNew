//===============================================================
// File: MTgraph.c
// Purpose: read text spectrum file generated by MTconvert
//          and produce a grayscale spectrogram in PostScript.
//
// Usage:
//   MTgraph spectrum.txt output.ps
//
// Example:
//   MTgraph spectrum.txt spectrogram.ps
//===============================================================

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

#include "PSpkg.h"
#include "MTpkg.h"

int main(int argc, char *argv[])
{
#define STARTSECONDS (0.)
#define NSECONDS (200.)
#define SECSPERPAGE (8.)

#define MAXSHOTS (1000)
#define MINTONE (0)
#define NTONES (288)

#define SIDEX (770.)
#define SIDEY (590.)
#define OFFX (10.)
#define OFFY (10.)

#define DYNAMICRANGE (20.)

    //------------------------------------------------------------
    // Command line parsing
    //------------------------------------------------------------
    if (argc != 3) {
        fprintf(stderr, "Usage: %s spectrum.txt output.ps\n", argv[0]);
        return 1;
    }

    const char *spectrumfile = argv[1];
    const char *psfile = argv[2];

    FILE *in = fopen(spectrumfile, "r");
    if (!in) {
        perror("Cannot open spectrum input file");
        return 1;
    }
    
//fprintf(stderr, "DEBUG: before\n");////////////////////////////////////

    PSopen(psfile);
    fprintf(stderr, "Input: %s\nOutput: %s\n", spectrumfile, psfile);

    //------------------------------------------------------------
    // Variable declarations
    //------------------------------------------------------------
    int retcode;
    int irecord = 0;
    double fourier[NFREQS];
    double fourierror[NFREQS];
    double avgvol;
    int isample;
    double seconds = 0.0;

    double xvalue, ynote;
    int ipage, ishot, itone, ibound, inote, notelow, notehigh;
    char tempstring[32];

    double a, b; // constants for log scale

    int boundary[(int)floor(SECSPERPAGE)+1];
    int secboundary[(int)floor(SECSPERPAGE)+1];
    int nboundaries = 0;
    int lastsecboundary = 0;

    double lastpagesecs = STARTSECONDS;
    int nshots = 0;
    double maxfourier = 1.;

    double dblimg[MAXSHOTS][NTONES];
    char img[MAXSHOTS * NTONES];
    int icolor;
    
    

    //------------------------------------------------------------
    // Read header
    //------------------------------------------------------------
    //FILE *old_stdin = stdin;
    //stdin = in;                       // allow existing MTpkg I/O functions to work
    retcode = checkheader(in);
    if (retcode != 0) {
        fprintf(stderr, "Bad file format\n");
        PSclose();
        //stdin = old_stdin;
        fclose(in);
        return 1;
    }

    //------------------------------------------------------------
    // Page loop
    //------------------------------------------------------------
    for (ipage = 0; seconds < STARTSECONDS + NSECONDS; ++ipage) {
    

        // Snapshot loop for each page
        for (ishot = 0; seconds - lastpagesecs < SECSPERPAGE; ++ishot) {

            ++irecord;
            retcode = readfourier(in,&isample, &seconds, &avgvol,
                                  &fourier[0], &fourierror[0]);

            if (retcode != 1) {    // readfourier returns 1 on success
                if (retcode == 0)
                    fprintf(stderr, "End of file at record %d\n", irecord);
                else
                    fprintf(stderr, "Read error at record %d\n", irecord);
                break;
            }
        

            if (seconds <= STARTSECONDS)
                continue; // wait for cue point

            if (nshots >= MAXSHOTS) {
                fprintf(stderr, "Too many snapshots in one page\n");
                PSclose();
                //stdin = old_stdin;
                fclose(in);
                return 1;
            }

            // One-second boundary markers
            if (lastsecboundary < floor(seconds)) {
                boundary[nboundaries] = ishot;
                secboundary[nboundaries] = floor(seconds);
                ++nboundaries;
                lastsecboundary = floor(seconds);
            }

            // Copy snapshot
            for (itone = 0; itone < NTONES; ++itone) {
                xvalue = fourier[MINTONE + itone];
                dblimg[nshots][itone] = xvalue;
                if (maxfourier < xvalue) maxfourier = xvalue;
            }

            ++nshots;
            if (seconds >= STARTSECONDS + NSECONDS)
                break;

        } // end snapshot loop

        if (nshots == 0)
            break;
            

        //--------------------------------------------------------
        // Normalize image and draw
        //--------------------------------------------------------
        a = 256. / log(DYNAMICRANGE);
        b = -a * log(maxfourier / DYNAMICRANGE);

        for (ishot = 0; ishot < nshots; ++ishot)
            for (itone = 0; itone < NTONES; ++itone) {
                int value = dblimg[ishot][itone] / maxfourier * 256;
                if (value < 0) value = 0;
                if (value >= 256) value = 255;
                img[ishot + nshots * itone] = (char)value;
            }

        // PS coordinate system (landscape)
        //PStranslate(0., 792.);
        //PSrotate(-90.);

        fprintf(stderr, "Image: nshots=%d, NTONES=%d\n", nshots, NTONES);
        

        PSrectangleFill(0., 0., 800., 620., 0., 0., 0.);

        PSimage(OFFX, OFFY,
                SIDEX * (seconds - lastpagesecs) / SECSPERPAGE,
                SIDEY,
                nshots, NTONES, &img[0]);

        PSrectangleBorder(OFFX, OFFY,
                          OFFX + SIDEX * (seconds - lastpagesecs) / SECSPERPAGE,
                          OFFY + SIDEY,
                          1., 1., 1., 1.);


        
        // One-second lines and labels
        PSsetfont("Times-Roman", 12.);
        PSsetrgbcolor(1., 1., 1.);

        for (ibound = 0; ibound < nboundaries; ++ibound) {
            PSline(OFFX + SIDEX * (seconds - lastpagesecs) / SECSPERPAGE *
                          boundary[ibound] / nshots,
                   OFFY,
                   OFFX + SIDEX * (seconds - lastpagesecs) / SECSPERPAGE *
                          boundary[ibound] / nshots,
                   OFFY + SIDEY,
                   .1, 1., 1., 1.);
            sprintf(tempstring, "%d ", secboundary[ibound]);
            PSmoveto(OFFX + SIDEX * (seconds - lastpagesecs) / SECSPERPAGE *
                             boundary[ibound] / nshots,
                     OFFY + 10.);
            PSshowright(tempstring);
        }

        // Horizontal note lines
        notelow  = floor(MINNOTE + (double)MINTONE / (double)TONESTEPS + .999);
        notehigh = floor((double)NTONES / TONESTEPS) + notelow;

        {
            double col[12][3] =
                {{0.5,0.5,0.5},{0.,0.,1.},{0.3,0.3,0.0},{0.,0.,1.},{0.3,0.3,0.0},
                 {0.3,0.3,0.0},{0.,0.,1.},{0.3,0.3,0.0},{0.,0.,1.},{0.3,0.3,0.0},
                 {0.,0.,1.},{0.3,0.3,0.0}};

            for (inote = notelow; inote <= notehigh; ++inote) {
                ynote = OFFY + (inote - (MINNOTE + MINTONE/TONESTEPS - 0.5/TONESTEPS))
                                * TONESTEPS * SIDEY / NTONES;
                icolor = inote % 12;
                PSline(OFFX, ynote, OFFX + SIDEX, ynote,
                       0.3,
                       col[icolor][0], col[icolor][1], col[icolor][2]);
            }
        }
//fprintf(stderr, "DEBUG: end\n");///////////////////////////////////////////////

        PSshowpage();

        // Reset for next page
        lastpagesecs = seconds;
        nshots = 0;
        maxfourier = 1.;
        nboundaries = 0;
    } // end page loop

    //------------------------------------------------------------
    // Cleanup
    //------------------------------------------------------------
    PSclose();
    //stdin = old_stdin;
    fclose(in);

//fprintf(stderr, "DEBUG: end\n");///////////////////////////////////////////////

    fprintf(stderr, "Done.\n");
    return 0;
}

// MTgraph - Luciano Ristori 
//
// read file generated by MTconvert and make graph in grey scale
// 
//

# include "MTpkg.c"

int main(){

#define STARTSECONDS (0.)
#define NSECONDS (200.)
#define SECSPERPAGE (8.)

#define MAXSHOTS (1000)
#define MINTONE (0)
#define NTONES (288)

#define SIDEX (770.)
#define SIDEY (590.)
#define OFFX (10.)
#define OFFY (10.)

#define DYNAMICRANGE (20.)

  int retcode;
  int irecord = 0;
  double fourier[NFREQS];
  double fourierror[NFREQS];
  double avgvol;
  int isample;
  int value;
  double xvalue, ynote;
  int ipage, ishot, itone, ibound, inote, notelow, notehigh;
  char tempstring[32];

  double a, b; //constants for log scale

  int boundary[(int)floor(SECSPERPAGE)+1];
  int secboundary[(int)floor(SECSPERPAGE)+1];
  int nboundaries = 0;
  int lastsecboundary = 0;

  double lastpagesecs = STARTSECONDS;
  double seconds=0.;
  int nshots = 0;
  double maxfourier= 1.;

  double dblimg[MAXSHOTS][NTONES];
  char img[MAXSHOTS*NTONES];

  int icolor;

  // color of piano keys

#define OCTAVE {0.5, 0.5, 0.5}
#define WHITE  {0.3, 0.3, 0.0}
#define BLACK  {0.0, 0.0, 1.0}

  double col[12][3] = 
    {OCTAVE,BLACK,WHITE,BLACK,WHITE,
     WHITE,BLACK,WHITE,BLACK,WHITE,BLACK,WHITE };


  // check file format - read input file header

  retcode = checkheader();

  if(retcode !=0) {
    fprintf(stderr,"Bad file format\n");
    return 1;
  }


  // loop on pages

  for(ipage=0; seconds < STARTSECONDS+NSECONDS; ++ipage){

  // loop on snapshots for each page

    for(ishot=0; seconds - lastpagesecs < SECSPERPAGE ;++ishot){
      
      ++irecord;
      retcode = readfourier(&isample, &seconds, &avgvol, &fourier[0], &fourierror[0]);

      // EOF or read error

      if(retcode != 0){
      if(retcode == 1)fprintf(stderr,"End of file at record %d\n", irecord);
      if(retcode == 2)fprintf(stderr,"Read error at record %d\n", irecord);
      break;
      }
    
      if(seconds <= STARTSECONDS) continue;// find cue point
      if(nshots >= MAXSHOTS){// too many snapshots
	fprintf(stderr,"Too many snapshots in one page\n");
	return 1;
      }

      // check for 1 sec boundary

      if(lastsecboundary < floor(seconds)){
	boundary[nboundaries]= ishot;// record snapshot number
	secboundary[nboundaries]= floor(seconds);// record seconds
	++nboundaries;
	lastsecboundary = floor(seconds);
      }

      // copy snapshot into local array dblimg

      for(itone = 0; itone < NTONES; ++itone){
	xvalue=fourier[MINTONE+itone];
	//if(xvalue > 0.)xvalue = sqrt(xvalue);// sqrt scale
	dblimg[nshots][itone]=xvalue;
	if(maxfourier < xvalue)maxfourier = xvalue;
      }

      ++nshots;
      if(seconds >= STARTSECONDS+NSECONDS) break;

    }// close loop on snapshots


  // fill normalized image

    a = 256./log(DYNAMICRANGE);
    b = -a*log(maxfourier/DYNAMICRANGE);

    for(ishot=0; ishot<nshots; ++ishot)
      for(itone=0; itone<NTONES; ++itone){
	value= dblimg[ishot][itone]/maxfourier*256;// linear scale
	//if(dblimg[ishot][itone]>0.)
	//value = floor(b + a*log(dblimg[ishot][itone]));// log scale
	//else
	//  value = 0;
	//fprintf(stderr," value %d\n",value);
	if(value < 0) value = 0;
	if(value >= 256) value = 255;
	img[ishot+nshots*itone]=value;
      }

    // display image

    if(nshots == 0) break;

  // set coordinate system for PS graphics (landscape)

    PStranslate(0.,792.);
    PSrotate(-90.);

    fprintf(stderr,"Image: nshots= %d, NTONES= %d\n", nshots, NTONES);

    PSrectangleFill(0.,0.,800.,620.,0.,0.,0.);// fill page with black
    PSimage(OFFX,OFFY,SIDEX*(seconds-lastpagesecs)/SECSPERPAGE,SIDEY,nshots,NTONES,&img[0]);// draw image
    PSrectangleBorder(OFFX,OFFY,OFFX+SIDEX*(seconds-lastpagesecs)/SECSPERPAGE,OFFY+SIDEY,1.,1.,1.,1.);// border

    // draw one second boundaries lines
    PSsetfont("Times-Roman",12.);

    PSsetrgbcolor(1.,1.,1.);// set font color to white (on black)

    for(ibound = 0; ibound<nboundaries ; ++ibound){
      PSline(OFFX+SIDEX*(seconds-lastpagesecs)/SECSPERPAGE*boundary[ibound]/nshots,OFFY,
	     OFFX+SIDEX*(seconds-lastpagesecs)/SECSPERPAGE*boundary[ibound]/nshots,OFFY+SIDEY, 
	     .1, 1.,1.,1.);
      // draw labels for one second boundaries
      sprintf(tempstring,"%d ",secboundary[ibound]);
      PSmoveto(OFFX+SIDEX*(seconds-lastpagesecs)/SECSPERPAGE*boundary[ibound]/nshots,
	       OFFY+ 10.);
      PSshowright(tempstring);
    }

    // draw one line for each note

    notelow = floor(MINNOTE+(double)MINTONE/(double)TONESTEPS+.999);
    notehigh =floor((floor)NTONES/TONESTEPS)+notelow;

    for(inote = notelow; inote <= notehigh; ++inote){
      ynote = OFFY+(inote-(MINNOTE+MINTONE/TONESTEPS-0.5/TONESTEPS))*TONESTEPS*SIDEY/NTONES;
      icolor=inote %12;
      PSline(OFFX,ynote,OFFX+SIDEX,ynote,0.3,col[icolor][0],col[icolor][1],col[icolor][2]);
    }

    PSshowpage();

    // reset variables for next page

    lastpagesecs = seconds;
    nshots=0;
    maxfourier=1.;
    nboundaries =0.;
  
  }// close loop on pages
  
}// end main

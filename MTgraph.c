// MTgraph - Luciano Ristori (adapted)
// read text spectrum file generated by MTconvert and make graph in grey scale
//
// Usage:
//   MTgraph               -> read spectrum from stdin, write spectrogram.ps
//   MTgraph spectrum.txt  -> read from spectrum.txt, write spectrogram.ps
//   MTgraph spectrum.txt out.ps -> read from spectrum.txt, write out.ps
//

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

#include "PSpkg.h"
#include "MTpkg.h"

int main(int argc, char *argv[])
{
#define STARTSECONDS (0.)
#define NSECONDS (200.)
#define SECSPERPAGE (8.)

#define MAXSHOTS (1000)
#define MINTONE (0)
#define NTONES (288)

#define SIDEX (770.)
#define SIDEY (590.)
#define OFFX (10.)
#define OFFY (10.)

#define DYNAMICRANGE (20.)

    // --------------------------------------------------------
    // pick input and output
    // --------------------------------------------------------
    FILE *in = stdin;
    const char *psout = "spectrogram.ps";

    if (argc >= 2) {
        if (strcmp(argv[1], "-") != 0) {
            in = fopen(argv[1], "r");
            if (!in) {
                perror("Cannot open spectrum input file");
                return 1;
            }
            // readfourier in MTpkg.c reads from stdin,
            // so redirect stdin to this file
            if (!freopen(argv[1], "r", stdin)) {
                perror("Cannot reopen input as stdin");
                return 1;
            }
        }
    }

    if (argc >= 3) {
        psout = argv[2];
    }

    PSopen(psout);

    int retcode;
    int irecord = 0;
    double fourier[NFREQS];
    double fourierror[NFREQS];
    double avgvol;
    int isample;
    double seconds = 0.0;

    double xvalue, ynote;
    int ipage, ishot, itone, ibound, inote, notelow, notehigh;
    char tempstring[32];

    double a, b; // constants for log scale

    int boundary[(int)floor(SECSPERPAGE)+1];
    int secboundary[(int)floor(SECSPERPAGE)+1];
    int nboundaries = 0;
    int lastsecboundary = 0;

    double lastpagesecs = STARTSECONDS;
    int nshots = 0;
    double maxfourier = 1.;

    double dblimg[MAXSHOTS][NTONES];
    char img[MAXSHOTS * NTONES];

    int icolor;

    // --------------------------------------------------------
    // first, read the text header that writefourier() prints:
    //   # version ...
    //   # minfreq ...
    //   ...
    // --------------------------------------------------------
    retcode = checkheader(stdin);
    if (retcode != 0) {
        fprintf(stderr, "Bad file format\n");
        PSclose();
        return 1;
    }

    // loop on pages
    for (ipage = 0; seconds < STARTSECONDS + NSECONDS; ++ipage) {

        // loop on snapshots for each page
        for (ishot = 0; seconds - lastpagesecs < SECSPERPAGE; ++ishot) {

            ++irecord;
            retcode = readfourier(&isample, &seconds, &avgvol,
                                  &fourier[0], &fourierror[0]);

            // EOF or read error
            if (retcode != 1) {    // our text readfourier returns 1 on success
                if (retcode == 0)
                    fprintf(stderr, "End of file at record %d\n", irecord);
                else
                    fprintf(stderr, "Read error at record %d\n", irecord);
                break;
            }

            if (seconds <= STARTSECONDS)
                continue; // find cue point

            if (nshots >= MAXSHOTS) { // too many snapshots
                fprintf(stderr, "Too many snapshots in one page\n");
                PSclose();
                return 1;
            }

            // check for 1 sec boundary
            if (lastsecboundary < floor(seconds)) {
                boundary[nboundaries] = ishot;             // snapshot number
                secboundary[nboundaries] = floor(seconds);  // seconds
                ++nboundaries;
                lastsecboundary = floor(seconds);
            }

            // copy snapshot into local array dblimg
            for (itone = 0; itone < NTONES; ++itone) {
                xvalue = fourier[MINTONE + itone];
                dblimg[nshots][itone] = xvalue;
                if (maxfourier < xvalue) maxfourier = xvalue;
            }

            ++nshots;
            if (seconds >= STARTSECONDS + NSECONDS)
                break;
        } // end snapshot loop

        // fill normalized image
        if (nshots == 0)
            break;

        a = 256. / log(DYNAMICRANGE);
        b = -a * log(maxfourier / DYNAMICRANGE);

        for (ishot = 0; ishot < nshots; ++ishot)
            for (itone = 0; itone < NTONES; ++itone) {
                int value = dblimg[ishot][itone] / maxfourier * 256; // linear
                if (value < 0) value = 0;
                if (value >= 256) value = 255;
                img[ishot + nshots * itone] = (char)value;
            }

        // set coordinate system for PS graphics (landscape)
        PStranslate(0., 792.);
        PSrotate(-90.);

        fprintf(stderr, "Image: nshots= %d, NTONES= %d\n", nshots, NTONES);

        PSrectangleFill(0., 0., 800., 620., 0., 0., 0.); // fill page with black
        PSimage(OFFX, OFFY,
                SIDEX * (seconds - lastpagesecs) / SECSPERPAGE,
                SIDEY,
                nshots, NTONES, &img[0]);                 // draw image
        PSrectangleBorder(OFFX, OFFY,
                          OFFX + SIDEX * (seconds - lastpagesecs) / SECSPERPAGE,
                          OFFY + SIDEY,
                          1., 1., 1., 1.);                 // border

        // draw one second boundaries lines
        PSsetfont("Times-Roman", 12.);
        PSsetrgbcolor(1., 1., 1.); // white

        for (ibound = 0; ibound < nboundaries; ++ibound) {
            PSline(OFFX + SIDEX * (seconds - lastpagesecs) / SECSPERPAGE *
                          boundary[ibound] / nshots,
                   OFFY,
                   OFFX + SIDEX * (seconds - lastpagesecs) / SECSPERPAGE *
                          boundary[ibound] / nshots,
                   OFFY + SIDEY,
                   .1, 1., 1., 1.);
            // labels
            sprintf(tempstring, "%d ", secboundary[ibound]);
            PSmoveto(OFFX + SIDEX * (seconds - lastpagesecs) / SECSPERPAGE *
                             boundary[ibound] / nshots,
                     OFFY + 10.);
            PSshowright(tempstring);
        }

        // draw horizontal lines for each note
        notelow = floor(MINNOTE + (double)MINTONE / (double)TONESTEPS + .999);
        notehigh = floor((double)NTONES / TONESTEPS) + notelow;

        {
            double col[12][3] =
                {{0.5,0.5,0.5},{0.,0.,1.},{0.3,0.3,0.0},{0.,0.,1.},{0.3,0.3,0.0},
                 {0.3,0.3,0.0},{0.,0.,1.},{0.3,0.3,0.0},{0.,0.,1.},{0.3,0.3,0.0},
                 {0.,0.,1.},{0.3,0.3,0.0}};

            for (inote = notelow; inote <= notehigh; ++inote) {
                ynote = OFFY + (inote - (MINNOTE + MINTONE/TONESTEPS - 0.5/TONESTEPS))
                                * TONESTEPS * SIDEY / NTONES;
                icolor = inote % 12;
                PSline(OFFX, ynote, OFFX + SIDEX, ynote,
                       0.3,
                       col[icolor][0], col[icolor][1], col[icolor][2]);
            }
        }

        PSshowpage();

        // reset for next page
        lastpagesecs = seconds;
        nshots = 0;
        maxfourier = 1.;
        nboundaries = 0;
    } // end page loop

    PSclose();
    return 0;
}
